{"meta":{"title":"tg0825","subtitle":"programing diary","description":null,"author":"tg0825","url":"https://tg0825.github.io"},"pages":[],"posts":[{"title":"Object.assign()","slug":"assign","date":"2018-03-13T00:21:23.000Z","updated":"2018-03-13T01:00:33.797Z","comments":true,"path":"2018/03/13/assign/","link":"","permalink":"https://tg0825.github.io/2018/03/13/assign/","excerpt":"","text":"Object.assign()Object.assign() 메소드는 열거할 수 있는 하나 이상의 소스 오브젝트로 부터 타겟 오브젝트로 프로퍼티를 복사하는데 사용됩니다. 그리고, 타겟 오브젝트가 반환될 것입니다. 문법1Object.assign(target, ...sources) 인자target: 타겟 오브젝트sources: 하나 이상의 소스 오브젝트 리턴값타겟 오브젝트 설명소스 프로퍼티와 동일한 프로퍼티의 키를 가진 타켓 오브젝트의 프로퍼티들은 소스 오브젝트의 프로퍼티로 덮어쓰기 될 것입니다. Object.assign() 메소드는 열거할 수 있는 오브젝트의 프로퍼티들만 타겟 오브젝트로 복사합니다. 이 메소드는 소스 오브젝트 대상으로 게터를 호출하고, 타겟 오브젝트 대상으로 세터를 호출합니다. 따라서, 소스 오브젝트의 프로퍼티를 그냥 단순히 복사하거나, 새로운 프로퍼티를 생성하는 것이 아니라, 타겟 오브젝트의 프로퍼티를 게터와 세터를 이용하여 할당할 수도 있습니다. 만약, 병합되는 소스 오브젝트가 게터를 포함하고 있다면, 새로운 프로퍼티를 타겟의 프로토타입에 병합하는 것은 알맞지 않을 것입니다. 열거 가능성을 포함한 프로퍼티를 프로토타입으로 복사하기 위해서는 Object.getOwnPropertyDescriptor()와 Object.defineProperty()을 사용하시기 바랍니다. String과 Symbol 프로퍼티 둘 다 복사될 것 입니다. 프로퍼티가 쓰기불가능(non-writable)등과 같이 만약 에러가 발생할 수 있는 상황에서는, TypeError가 발생하고 타겟 오브젝트에는 변화가 없을 것입니다. Object.assign() 메소드는 null이나 undefiend는 반환하지 않으니 주의하세요. 예제들객체 복제하기123var obj = &#123;a: 1&#125;;var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123;a: 1&#125; 깊은 복제에 대한 주의사항깊은 복제에 대해서는 대안적인 방법을 사용할 필요가 있습니다. 왜냐하면, Object.assign()은 타겟 오브젝트에 할당을 할 때, 프로퍼티의 참조를 복사하기 때문입니다. 참조: MDN","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://tg0825.github.io/tags/es6/"},{"name":"Object","slug":"Object","permalink":"https://tg0825.github.io/tags/Object/"},{"name":"assign","slug":"assign","permalink":"https://tg0825.github.io/tags/assign/"}]},{"title":"promise","slug":"promise","date":"2018-02-27T16:27:39.000Z","updated":"2018-03-06T00:49:18.519Z","comments":true,"path":"2018/02/28/promise/","link":"","permalink":"https://tg0825.github.io/2018/02/28/promise/","excerpt":"","text":"Promise객체는 비동기 계산을 위해 사용됩니다. Promise는 아직은 아니지만 나중에 완료될 것으로 기대되는 연산을 표현합니다. 구문1new Promise(/* executor */ function (resolve, reject) &#123; ... &#125;); 매개변수resolve 및 reject 인수를 통해 다른 함수에 전달될 함수 입니다. executor함수는 resolve 및 reject 함수를 제공하는 promise 구현에 의해 죽시 실행됩니다. 예Promise 생성참조: MDN web docs","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://tg0825.github.io/tags/es6/"}]},{"title":"Destructuring assignment","slug":"destructuring-assignment","date":"2018-02-24T04:49:38.000Z","updated":"2018-03-06T00:48:57.275Z","comments":true,"path":"2018/02/24/destructuring-assignment/","link":"","permalink":"https://tg0825.github.io/2018/02/24/destructuring-assignment/","excerpt":"","text":"비구조화 할당(destructuring assignment) 구문은 배열의 값이나 객체의 속성을 별개의 변수로 추출할 수 있게 하는 자바스크립트 식(expression)입니다. 구문12345678910111213141516171819var a, b, rest;[a, b] = [10, 20];console.log(a); // 10console.log(b); // 20[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50](&#123;a, b&#125; = &#123;a: 10, b: 20&#125;);console.log(a); // 10console.log(b); // 20// Stage 32 proposal(&#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;);console.log(a); // 10console.log(b); // 20console.log(rest); // &#123;c: 30, d: 40&#125; 설명객체 및 배열 리터럴 식은 즉석에서 쉽게 데이터 패키지를 만들 수 있도록 합니다.1var x = [1, 2, 3, 4, 5]; 비구조화 할당은 비슷한 구문이지만, 할당문의 좌변에 원래 변수에서 어떤 값들을 추출할지 정의합니다.1234var x = [1, 2, 3, 4, 5];var [y, z] = x;console.log(y); // 1console.log(z); // 2 이 기능은 Perl이나 Python 같은 언어에 존재하는 것과 비슷합니다. 배열 비구조화기본값배열 인자의 값이 undefiend인 경우에는 기본값을 할당할 수 있습니다.1234var a, b;[a = 5, b = 7] = [1];console.log(a); // 1console.log(b); // 7 변수에 배열의 나머지를 할당하기비구조화 할당시, rest패턴을 이용해 배열의 남은 부분을 변수 하나에 할당할 수 있습니다.123var [a, ...b] = [1, 2, 3];console.log(a); // 1console.log(b); // [2, 3] 객체 비구조화기본 할당12345var o = &#123;p: 42, q: true&#125;var &#123;p, q&#125; = o;console.log(p); // 42console.log(q); // true 선언 없는 할당변수의 선언과 분리하여 변수에 값을 할당할 수 있습니다.12var a, b;(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;); 할당 문을 둘러싼 ( .. )는 선언 없이 객체 리터럴 비구조화 할당을 사용할 때 필요한 구문입니다.{a, b} = {a:1 ,b:2}는 유효한 독립 구문이 아닙니다. 좌변의 {a, b}이 블록으로 간주되고 객체 리터럴이 아니기 때문입니다.그러나 ({a, b} = {a:1, b:2})는 유효한데, var {a, b} = {a:1 , b:2}의 형태와 같습니다.참고: ( .. ) 표현식 앞에 세미콜론이 없다면 이전 줄에 있는 함수 실행을 위해 이용될 수 있습니다. 새로운 변수 이름으로 할당하기변수를 추출해서 원래 객체 속성명과는 다른 이름으로 할당시킬 수 있습니다.1234var o = &#123;p: 42, q: true&#125;;var &#123;p: foo, q: bar &#125; = o;console.log(foo); // 42console.log(bar); // true 기본값123var &#123;a = 10, b = 5&#125; = &#123;a: 3&#125;;console.log(a); // 3console.log(b); // 5 기본값을 제공하여 새로운 변수 이름으로 할당하기123var &#123;a:aa = 10, b:bb = 5&#125; = &#123;a: 3&#125;;console.log(aa); // 3console.log(bb); // 5 중첩 객체 및 배열 비구조화함수 매개변수로 전달된 객체에서 필드 가져오기12345678910111213141516171819function userId(&#123;id&#125;) &#123; return id;&#125;function whois(&#123;displayName: displayName, fullName: &#123;firstName: name&#125;&#125;) &#123; console.log(displayName + ' is ' + name);&#125;var user = &#123; id: 42, displayName: 'jdoe', fullName: &#123; firstName: 'John', lastName: 'Doe' &#125;&#125;console.log('userId: ' + userId(user)); // 'userId: 42'whois(user); // 'jdoe is John' 객체 비구조화시 나머지 (rest)Rest/Spread Properties for ECMAScript 제안 (stage 3)은 나머지 (rest) 구문을 비구조화에 추가합니다. 나머지 속성 구문은 비구조화를 추출하고 남은 객체의 enumerable한 속성들을 모두 모아줍니다.1234let &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;a; // 10b; // 20rest; // &#123;c: 30, d: 40&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://tg0825.github.io/tags/es6/"}]},{"title":"Class","slug":"class","date":"2018-01-31T15:25:27.000Z","updated":"2018-03-06T00:48:53.104Z","comments":true,"path":"2018/02/01/class/","link":"","permalink":"https://tg0825.github.io/2018/02/01/class/","excerpt":"","text":"Class개요es6에서는 class가 추가 됐습니다. class를 선언하기 위해선 class 키워드를 사용해야 합니다. 123class Human &#123; // do something&#125; constructor(생성자)constructor 메소드는 class로 생성된 객체를 생성하고 초기화하기 위한 특수한 메소드입니다. constructor라는 메서드는 한개만 존재할 수 있습니다. 한개 이상 사용하면 SyntaxError가 발생합니다. constructor는 부모 클래스의 constructor를 호출하기 위해 super키워드를 사용할 수 있습니다. 1234567class Human &#123; constructor(height, width) &#123; super() this.height = height; this.width = width; &#125;&#125; Static methodsstatic 키워드는 클래스를 위한 정적(static) 메소드를 정의합니다. 정적 메소드는 클래스의 인스턴스화 없이 호출되며, 클래스의 인스턴스에서는 호출할 수 없습니다. 정적 메소드는 어플리케이션을 위한 유틸리티 함수를 생성하는데 주로 사용 됩니다. 123456789101112131415161718class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; static distance(a, b) &#123; const dx = a.x - b.x; const dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); &#125;&#125;const p1 = new Point(5, 5);const p2 = new Point(10, 10);console.log(Point.distance(p1, p2)); extends를 통한 클래스 상속 (sub classing)extends 키워드는 클래스 선언이나 클래스 표현식에서 다른 클래스의 자식 클래스를 생성하기 위해 사용 됩니다. 123456789101112131415class Animal &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Dog extends Animal &#123; speak() &#123; console.log(this.name + 'barks.'); &#125;&#125; super를 통한 상위 클래스 호출super키워드는 객체의 부모가 가지고 있는 함수들을 호출하기 위해 사용됩니다.12345678910111213141516171819202122class Cat &#123; constructor(name) &#123; this.name = name || 'noname'; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Lion extends Cat &#123; constructor() &#123; super(); &#125; speak() &#123; super.speak(); console.log(this.name + ' roars.'); &#125;&#125;const lion = new Lion();","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://tg0825.github.io/tags/es6/"},{"name":"class","slug":"class","permalink":"https://tg0825.github.io/tags/class/"}]},{"title":"arrow function","slug":"arrow-function","date":"2018-01-31T14:51:46.000Z","updated":"2018-03-06T00:48:38.003Z","comments":true,"path":"2018/01/31/arrow-function/","link":"","permalink":"https://tg0825.github.io/2018/01/31/arrow-function/","excerpt":"","text":"화살표 함수 표현(arrow function expression)은 function 표현에 비해 구문이 짧고 자신의 this, arguments, super 또는 new.target을 바인딩 하지 않습니다. 화살표 함수는 항상 익명입니다. 이 함수 표현은 메소드 함수가 아닌 곳에 가장 적당합니다. 그래서 생성자로서 사용할 수 없습니다. 구문기본 구문123456789(param1, param2, ..., paramN) =&gt; &#123;statements&#125;(param1, param2, ..., paramN) =&gt; expression // 다음과 동일함: =&gt; &#123;return expression;&#125;// 매개변수가 하나뿐인 경우 괄호는 선택사항:(singleParam) =&gt; &#123;statements&#125;singleParam =&gt; &#123;statements&#125;// 매개변수가 없는 함수는 괄호가 필요:() =&gt; &#123;statements&#125; 설명바인딩 되지 않은 this화살표 함수전까지는, 모든 새로운 함수는 자신의 this값을 정의 했습니다. (이 함수가 생성자인 경우는 새로운 객체, 엄격 모드 함수 호출에서는 undefiend, 함수가 “객체 메서드”로서 호출된 경우 문맥 객체 등). 이는 객체 지향 스타일 프로그래밍에서 성가신 일임이 드러났습니다. 화살표 함수는 자신만의 this를 생성하지 않습니다. this는 감싸고 있는 컨텍스트로 부터 원래의 의미를 갖습니다. 그래서 다음 코드는 기대한대로 작동합니다.123456789function Person() &#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // this는 정확히 person객체를 참조 &#125;, 1000);&#125;var p = new Person(); 엄격 모드와의 관계this 가 렉시컬(lexical, 정적)임을 감안하면, this에 관한 엄격 모드 규칙은 그냥 무시됩니다.12var f = () =&gt; &#123;'use strict'; return this&#125;;f() === window; // 또는 전역 객체 엄격 모드의 나머지 규칙은 평소대로 적용합니다. #함수 본문화살표 함수는 “간결한 본문”이든 보통 “블록 본문”이든 하나를 가질 수 있습니다.블록 본문 형태는 자동으로 값을 반환하지 않습니다. 명시된 return 문을 사용할 필요가 있습니다.12var func = x =&gt; x * x; //간결한 구문, 암시된 \"return\"var func = (x, y) =&gt; &#123;return x + y;&#125;; // 블록 본문이면, 명시된 \"return\"이 필요 객체 리터럴 반환간결한 구문 params =&gt; {object:literal}을 사용한 객체 리터럴 반환은 예상대로 작동하지 않음을 명시하세요.12var func = () =&gt; &#123;foo:1&#125; // func() 호출은 undefiend를 반환!var func = () =&gt; &#123;foo: function () &#123;&#125;&#125; // SyntaxError: function 문은 이름이 필요함 이는 중괄호({}) 안 코드가 일련의 문(즉 foo는 라벨처럼 취급됩니다, 객체 리터럴 내 키가 아니라)으로 파싱 되기 때문입니다. 객체 리터럴을 괄호로 감싸는 것을 기억하세요.1var func = () =&gt; (&#123;foo: 1&#125;);","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://tg0825.github.io/tags/es6/"},{"name":"function","slug":"function","permalink":"https://tg0825.github.io/tags/function/"},{"name":"arrow function","slug":"arrow-function","permalink":"https://tg0825.github.io/tags/arrow-function/"}]}]}