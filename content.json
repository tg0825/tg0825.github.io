{"meta":{"title":"tg0825","subtitle":"programing diary","description":null,"author":"tg0825","url":"https://tg0825.github.io"},"pages":[{"title":"about","date":"2018-03-18T05:18:57.000Z","updated":"2018-03-18T05:49:34.446Z","comments":true,"path":"about/index.html","permalink":"https://tg0825.github.io/about/index.html","excerpt":"","text":"concentration"}],"posts":[{"title":"hasOwnProperty","slug":"hasOwnProperty","date":"2018-03-16T14:00:37.000Z","updated":"2018-03-18T05:46:06.137Z","comments":true,"path":"2018/03/16/hasOwnProperty/","link":"","permalink":"https://tg0825.github.io/2018/03/16/hasOwnProperty/","excerpt":"","text":"hasOwnProperty() 메소드는 객체가 특정 프로퍼티를 가지고 있는지를 나타내는 불리언 값을 반환한다. 문법1obj.hasOwnProperty(prop) 파라미터prop: 테스트하려는 프로퍼티의 명칭 설명모든 객체는 hasOwnProperty를 상속하는 Object의 자식이다. 이 메소드는 객체가 특정 프로퍼티를 자기만의 직접적인프로퍼티로서 소유하고 있는지를 판단하는데 사용된다. in연산과는 다르게, 이 메소드는 객체의 프로토타입 체인을 확인하지는 않는다. 예제프로퍼티의 존재 여부를 테스트하기 위한 hasOwnProperty의 사용다음은 o 객체가 prop라는 명칭을 지닌 프로퍼티를 포함하는지를 판단하는 예제이다.12345678910o = new Object();o.prop = 'exists';function change0() &#123; o.newprop = o.prop; delete o.prop;&#125;o.hasOwnProperty('prop'); // returns truechange0();o.hasOwnProperty('prop'); // returns false 직접 프로퍼티와 상속된 프로퍼티의 비교다음은 직접 프로퍼티와 프로토타입 체인에서 상속된 프러퍼티 간의 차이점을 비교하는 예제이다.12345o = new Object();o.prop = 'exists';o.hasOwnProperty('prop'); // returns trueo.hasOwnProperty('toString'); // returns falseo.hasOwnProperty('hasOwnProperty'); // returns false 객체의 프로퍼티들을 순환하기123456789101112var buz = &#123; fog: 'stack'&#125;;for (var name in buz) &#123; if (buz.hasOwnProperty(name)) &#123; console.log('this is fog (' + name + ') for sure. value: ' + buz[name]); &#125; else &#123; console.log(name); // toString or something else &#125;&#125; 참조: MDN","categories":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"hasOwnProperty","slug":"hasOwnProperty","permalink":"https://tg0825.github.io/tags/hasOwnProperty/"}]},{"title":"deepcopy-shallowcopy","slug":"deepcopy-shallowcopy","date":"2018-03-13T01:17:53.000Z","updated":"2018-03-18T05:46:06.137Z","comments":true,"path":"2018/03/13/deepcopy-shallowcopy/","link":"","permalink":"https://tg0825.github.io/2018/03/13/deepcopy-shallowcopy/","excerpt":"","text":"","categories":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://tg0825.github.io/tags/es6/"},{"name":"deepcopy","slug":"deepcopy","permalink":"https://tg0825.github.io/tags/deepcopy/"},{"name":"shallowcopy","slug":"shallowcopy","permalink":"https://tg0825.github.io/tags/shallowcopy/"}]},{"title":"Object.assign()","slug":"assign","date":"2018-03-13T00:21:23.000Z","updated":"2018-03-18T05:46:06.137Z","comments":true,"path":"2018/03/13/assign/","link":"","permalink":"https://tg0825.github.io/2018/03/13/assign/","excerpt":"","text":"Object.assign()Object.assign() 메소드는 열거할 수 있는 하나 이상의 소스 오브젝트로 부터 타겟 오브젝트로 프로퍼티를 복사하는데 사용됩니다. 그리고, 타겟 오브젝트가 반환될 것입니다. 문법1Object.assign(target, ...sources) 인자target: 타겟 오브젝트sources: 하나 이상의 소스 오브젝트 리턴값타겟 오브젝트 설명소스 프로퍼티와 동일한 프로퍼티의 키를 가진 타켓 오브젝트의 프로퍼티들은 소스 오브젝트의 프로퍼티로 덮어쓰기 될 것입니다. Object.assign() 메소드는 열거할 수 있는 오브젝트의 프로퍼티들만 타겟 오브젝트로 복사합니다. 이 메소드는 소스 오브젝트 대상으로 게터를 호출하고, 타겟 오브젝트 대상으로 세터를 호출합니다. 따라서, 소스 오브젝트의 프로퍼티를 그냥 단순히 복사하거나, 새로운 프로퍼티를 생성하는 것이 아니라, 타겟 오브젝트의 프로퍼티를 게터와 세터를 이용하여 할당할 수도 있습니다. 만약, 병합되는 소스 오브젝트가 게터를 포함하고 있다면, 새로운 프로퍼티를 타겟의 프로토타입에 병합하는 것은 알맞지 않을 것입니다. 열거 가능성을 포함한 프로퍼티를 프로토타입으로 복사하기 위해서는 Object.getOwnPropertyDescriptor()와 Object.defineProperty()을 사용하시기 바랍니다. String과 Symbol 프로퍼티 둘 다 복사될 것 입니다. 프로퍼티가 쓰기불가능(non-writable)등과 같이 만약 에러가 발생할 수 있는 상황에서는, TypeError가 발생하고 타겟 오브젝트에는 변화가 없을 것입니다. Object.assign() 메소드는 null이나 undefiend는 반환하지 않으니 주의하세요. 예제들객체 복제하기123var obj = &#123;a: 1&#125;;var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123;a: 1&#125; 깊은 복제에 대한 주의사항깊은 복제에 대해서는 대안적인 방법을 사용할 필요가 있습니다. 왜냐하면, Object.assign()은 타겟 오브젝트에 할당을 할 때, 프로퍼티의 참조를 복사하기 때문입니다. 1234567891011121314151617181920212223242526function test() &#123; let a = &#123; b: &#123; c: 4 &#125;, d: &#123; e: &#123; f: 1 &#125; &#125; &#125; let g = Object.assign(&#123;&#125;, a); let h = JSON.parse(JSON.stringify(a)); console.log(g.d); // &#123;e: &#123;f: 1&#125;&#125; g.d.e = 32; console.log('g.d.e set to 32.'); console.log(g); // &#123;b: &#123;c: 4&#125;, d: &#123;e: 32&#125;&#125; console.log(a); // &#123;b: &#123;c: 4&#125;, d: &#123;e: 32&#125;&#125; console.log(h); // &#123;b: &#123;c: 4&#125;, d: &#123;e: &#123;f: 1&#125;&#125;&#125; h.d.e = 54 console.log('h.d.e set to 54'); console.log(g); // &#123;b: &#123;c: 4&#125;, d: &#123;e: 32&#125;&#125; console.log(a); // &#123;b: &#123;c: 4&#125;, d: &#123;e: 32&#125;&#125; console.log(h); // &#123;b: &#123;c: 4&#125;, d: &#123;e: 54&#125;&#125;&#125;test(); 참조: MDN","categories":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://tg0825.github.io/tags/es6/"},{"name":"Object","slug":"Object","permalink":"https://tg0825.github.io/tags/Object/"},{"name":"assign","slug":"assign","permalink":"https://tg0825.github.io/tags/assign/"}]},{"title":"promise","slug":"promise","date":"2018-02-27T16:27:39.000Z","updated":"2018-03-25T06:19:42.521Z","comments":true,"path":"2018/02/28/promise/","link":"","permalink":"https://tg0825.github.io/2018/02/28/promise/","excerpt":"","text":"Promise객체는 비동기 계산을 위해 사용됩니다. Promise는 아직은 아니지만 나중에 완료될 것으로 기대되는 연산을 표현합니다. 구문1new Promise(/* executor */ function (resolve, reject) &#123; ... &#125;); 매개변수resolve 및 reject 인수를 통해 다른 함수에 전달될 함수 입니다. executor함수는 resolve 및 reject 함수를 제공하는 promise 구현에 의해 죽시 실행됩니다. executorresolve 및 reject 인수를 통해 다른 함수에 전달될 함수입니다 executor함수는 resolve 및 reject함수는 프로미스에 바인딩되고 둘을 호출하면 각각 프로미스를 이행(fulfill) 또는 거부(reject, 거절)합니다. executor는 일부 비동기 작업(work)을 시작하리라 예상되고 작업이 완료되면 프로미스의 최종값을 결정(resolve, 확정)하거나 오류가 발생하면 거부하기 위해 resolve또는 reject 함수를 호출합니다. 설명promise는 피로미스가 생성될 때 꼭 알 필요는 없는 값을 위한 대리자입니다. 이는 비동기 동작이 종료된 이후의 결과값이나 실패 이유를 처리하기 위한 처리기(handler)를 연결할 수 있도록 합니다. 프로미스는 비동기 메서드가 동기 메서드처럼 값을 반환하도록 합니다. 최종값 대신, 비동기 메서드는 미래 어느 시점에 값을 갖는 promise를 반환합니다. promise는 다음 중 하나의 상태를 가집니다. 대기중(pending): 초기 상태, 이행 또는 거부되지 않은. 이행됨(fulfilled): 연산이 성공리에 완료되었음을 뜻합니다. 거부됨(rejected): 연산이 실패했음을 뜻합니다. 대기중인 프로미스는 값으로 이행되거나, 이유(reason 또는 오류)와 함께 거부될 수 있습니다. 이 중 하나가 일어난 경우, 연결된 처리기는 호출된 프로미스의 then메서드에 의해 대기열에 오릅니다.(queued up).(프로미스에 처리기가 부착될 때 이미 이행 또는 거부된 경우에도 처리기는 호출되므로, 비동기 연산과 부착될 처리기 사이에는 경합 조건(race condition)이 없습니다.) Promise.prototype.then() 및 Promise.prototype.catch() 메서드가 프로미스를 반환하기에, 둘은 연결(chain)될 수 있습니다. - 합성(composition)이라고 불립니다. 속성Promise.length 값이 언제나 1인 Length 속성입니다. (생성자 인수의 수를 나타냅니다.) Promise.prototype Promise 생성자의 프로토타입을 나타냅니다. 메서드Promise.all(iterable)인수 iterable 내의 모든 프로미스가 결정된 때 결정되며 하나의 프로미스라도 거부된 경우 즉시 거부하는 프로미스를 반환합니다. 이 프로미스가 결정되는 경우, iterable 내의 프로미스가 결정한 값들의 배열로 결정됩니다. 반환된 프로미스가 거부되는 경우, iterable 내의 거부된 그 프로미스가 거부된 이유를 그대로 이용해 거부합니다. 이 메서드는 여러 프로미스의 결과를 모두 모으는 데 유용할 수 있습니다. Promise.race(iterable)iterable 내 프로미스 중 하나를 결정 또는 거부하자마자 결정 또는 거부하는 프로미스를 반환합니다. 그 프로미스로부터 값 또는 이유로. Promise.reject(reason)주어진 reason(이유)로 거부된 Promise 객체를 반환합니다. Promise.resolve(value)주어진 값(value)으로 결정된 Promise객체를 반환합니다. 값이 thenable 객체인 (즉 then 메서드가 있는) 경우, 반환된 프로미스는 그 thenable을 “따르고(follw)”, 그 최종 상태를 취합니다. 그렇지 않으면 반환된 프로미스는 그 값으로 이행됩니다. 보통, 값이 프로미스인지 아닌지 알고 싶은 경우 - 대신 Promise.resolve(value)로 쓰고 프로미스처럼 반환값으로 작동합니다. 예Promise 생성이 간단한 예는 Promise의 메커니즘을 보입니다. testPromise()메서드는 &lt;button&gt;이 클릭될 때마다 호출됩니다. 결정하는 프로미스를 만듭니다. 무작위로 1-3초마다 프로미스 셈(1부터 시작하는 숫자)에 window.setTimeout()을 사용하는 Promise() 생성자는 프로미스르 만드는데 쓰입니다. 프로미스 이행은 간단하게 기록됩니다. p1.then()을 사용하는 이행 콜백 세트를 통해. 기록 약간이 메서드의 동기 부분을 프로미스의 비동기 완료(completion)와 분리(decouple)되는 법을 보입니다. 12345678910111213141516171819202122232425262728293031323334353637'use strict';var promiseCount = 0;function testPromise() &#123; var thisPromiseCount = ++promiseCount; var log = document.getElementById('log'); log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Started (&lt;small&gt;sync code started &lt;/small&gt;) &lt;br/&gt;'); // 새 약속을 (생성) 합니다. 이 프로미스의 숫자 셈을 약소합니다. var p1 = new Promise( function (resolve, reject) &#123; log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Promise Started (&lt;small&gt; Async code started &lt;/small&gt;)&lt;br/&gt;'); window.setTimeout(function () &#123; // 프로미스 이행 resolve(thisPromiseCount); &#125;, Math.random() * 2000 + 1000); &#125; ) // 프로미스가 then() 호출로 결정된/ 이행된 경우 무엇을 할 지를 정의하고, // catch() 메서드는 프로미스가 거부된 경우 무엇을 할 지를 정의합니다. p1.then(function (val) &#123; log.insertAdjacentHTML('beforeend', val + ') Promise fulfilled (&lt;small&gt;Async code terminated&lt;/small&gt;)&lt;br/&gt;'); &#125;) .catch( // 거부 이유 기록 function(reason) &#123; console.log('Handle rejected promise ('+reason+') here.'); &#125; ) log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Promise made (&lt;small&gt;Sync code terminated&lt;/small&gt;)&lt;br/&gt;');&#125; 참조: MDN web docs","categories":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://tg0825.github.io/tags/es6/"}]},{"title":"Destructuring assignment","slug":"destructuring-assignment","date":"2018-02-24T04:49:38.000Z","updated":"2018-03-18T05:46:51.071Z","comments":true,"path":"2018/02/24/destructuring-assignment/","link":"","permalink":"https://tg0825.github.io/2018/02/24/destructuring-assignment/","excerpt":"","text":"비구조화 할당(destructuring assignment) 구문은 배열의 값이나 객체의 속성을 별개의 변수로 추출할 수 있게 하는 자바스크립트 식(expression)입니다. 구문12345678910111213141516171819var a, b, rest;[a, b] = [10, 20];console.log(a); // 10console.log(b); // 20[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50](&#123;a, b&#125; = &#123;a: 10, b: 20&#125;);console.log(a); // 10console.log(b); // 20// Stage 32 proposal(&#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;);console.log(a); // 10console.log(b); // 20console.log(rest); // &#123;c: 30, d: 40&#125; 설명객체 및 배열 리터럴 식은 즉석에서 쉽게 데이터 패키지를 만들 수 있도록 합니다.1var x = [1, 2, 3, 4, 5]; 비구조화 할당은 비슷한 구문이지만, 할당문의 좌변에 원래 변수에서 어떤 값들을 추출할지 정의합니다.1234var x = [1, 2, 3, 4, 5];var [y, z] = x;console.log(y); // 1console.log(z); // 2 이 기능은 Perl이나 Python 같은 언어에 존재하는 것과 비슷합니다. 배열 비구조화기본값배열 인자의 값이 undefiend인 경우에는 기본값을 할당할 수 있습니다.1234var a, b;[a = 5, b = 7] = [1];console.log(a); // 1console.log(b); // 7 변수에 배열의 나머지를 할당하기비구조화 할당시, rest패턴을 이용해 배열의 남은 부분을 변수 하나에 할당할 수 있습니다.123var [a, ...b] = [1, 2, 3];console.log(a); // 1console.log(b); // [2, 3] 객체 비구조화기본 할당12345var o = &#123;p: 42, q: true&#125;var &#123;p, q&#125; = o;console.log(p); // 42console.log(q); // true 선언 없는 할당변수의 선언과 분리하여 변수에 값을 할당할 수 있습니다.12var a, b;(&#123;a, b&#125; = &#123;a: 1, b: 2&#125;); 할당 문을 둘러싼 ( .. )는 선언 없이 객체 리터럴 비구조화 할당을 사용할 때 필요한 구문입니다.{a, b} = {a:1 ,b:2}는 유효한 독립 구문이 아닙니다. 좌변의 {a, b}이 블록으로 간주되고 객체 리터럴이 아니기 때문입니다.그러나 ({a, b} = {a:1, b:2})는 유효한데, var {a, b} = {a:1 , b:2}의 형태와 같습니다.참고: ( .. ) 표현식 앞에 세미콜론이 없다면 이전 줄에 있는 함수 실행을 위해 이용될 수 있습니다. 새로운 변수 이름으로 할당하기변수를 추출해서 원래 객체 속성명과는 다른 이름으로 할당시킬 수 있습니다.1234var o = &#123;p: 42, q: true&#125;;var &#123;p: foo, q: bar &#125; = o;console.log(foo); // 42console.log(bar); // true 기본값123var &#123;a = 10, b = 5&#125; = &#123;a: 3&#125;;console.log(a); // 3console.log(b); // 5 기본값을 제공하여 새로운 변수 이름으로 할당하기123var &#123;a:aa = 10, b:bb = 5&#125; = &#123;a: 3&#125;;console.log(aa); // 3console.log(bb); // 5 중첩 객체 및 배열 비구조화함수 매개변수로 전달된 객체에서 필드 가져오기12345678910111213141516171819function userId(&#123;id&#125;) &#123; return id;&#125;function whois(&#123;displayName: displayName, fullName: &#123;firstName: name&#125;&#125;) &#123; console.log(displayName + ' is ' + name);&#125;var user = &#123; id: 42, displayName: 'jdoe', fullName: &#123; firstName: 'John', lastName: 'Doe' &#125;&#125;console.log('userId: ' + userId(user)); // 'userId: 42'whois(user); // 'jdoe is John' 객체 비구조화시 나머지 (rest)Rest/Spread Properties for ECMAScript 제안 (stage 3)은 나머지 (rest) 구문을 비구조화에 추가합니다. 나머지 속성 구문은 비구조화를 추출하고 남은 객체의 enumerable한 속성들을 모두 모아줍니다.1234let &#123;a, b, ...rest&#125; = &#123;a: 10, b: 20, c: 30, d: 40&#125;a; // 10b; // 20rest; // &#123;c: 30, d: 40&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://tg0825.github.io/tags/es6/"}]},{"title":"Class","slug":"class","date":"2018-01-31T15:25:27.000Z","updated":"2018-03-18T05:46:06.137Z","comments":true,"path":"2018/02/01/class/","link":"","permalink":"https://tg0825.github.io/2018/02/01/class/","excerpt":"","text":"Class개요es6에서는 class가 추가 됐습니다. class를 선언하기 위해선 class 키워드를 사용해야 합니다. 123class Human &#123; // do something&#125; constructor(생성자)constructor 메소드는 class로 생성된 객체를 생성하고 초기화하기 위한 특수한 메소드입니다. constructor라는 메서드는 한개만 존재할 수 있습니다. 한개 이상 사용하면 SyntaxError가 발생합니다. constructor는 부모 클래스의 constructor를 호출하기 위해 super키워드를 사용할 수 있습니다. 1234567class Human &#123; constructor(height, width) &#123; super() this.height = height; this.width = width; &#125;&#125; Static methodsstatic 키워드는 클래스를 위한 정적(static) 메소드를 정의합니다. 정적 메소드는 클래스의 인스턴스화 없이 호출되며, 클래스의 인스턴스에서는 호출할 수 없습니다. 정적 메소드는 어플리케이션을 위한 유틸리티 함수를 생성하는데 주로 사용 됩니다. 123456789101112131415161718class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; static distance(a, b) &#123; const dx = a.x - b.x; const dy = a.y - b.y; return Math.sqrt(dx * dx + dy * dy); &#125;&#125;const p1 = new Point(5, 5);const p2 = new Point(10, 10);console.log(Point.distance(p1, p2)); extends를 통한 클래스 상속 (sub classing)extends 키워드는 클래스 선언이나 클래스 표현식에서 다른 클래스의 자식 클래스를 생성하기 위해 사용 됩니다. 123456789101112131415class Animal &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Dog extends Animal &#123; speak() &#123; console.log(this.name + 'barks.'); &#125;&#125; super를 통한 상위 클래스 호출super키워드는 객체의 부모가 가지고 있는 함수들을 호출하기 위해 사용됩니다.12345678910111213141516171819202122class Cat &#123; constructor(name) &#123; this.name = name || 'noname'; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Lion extends Cat &#123; constructor() &#123; super(); &#125; speak() &#123; super.speak(); console.log(this.name + ' roars.'); &#125;&#125;const lion = new Lion();","categories":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://tg0825.github.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://tg0825.github.io/tags/es6/"},{"name":"class","slug":"class","permalink":"https://tg0825.github.io/tags/class/"}]}]}